#!/usr/bin/env python


import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    open(os.path.join(partial_path, "__init__.py"), "w").write("\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "w") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('agents/distributed_agent.py', 'from kaggle_environments.envs.halite.helpers import Board, ShipAction, ShipyardAction\n\nfrom actors.ship_actor_container import ShipActorContainer\nfrom actors.shipyard_actor_container import ShipyardActorContainer\nfrom agents.base_agent import BaseAgent\nfrom government.government import Government\n\n\nclass DistributedAgent(BaseAgent):\n    def __init__(self):\n        super().__init__()\n        self.ship_actor_container = ShipActorContainer()\n        self.shipyard_actor_container = ShipyardActorContainer()\n        # self.government = Government()\n\n        # Government-actors communication\n        self.ship_flags = None\n        self.shipyard_flags = None\n        self.government_flags = None\n\n    def get_actions(self, board):\n        self.ship_flags = self.ship_actor_container.update(board, government_flags=self.government_flags)\n        self.shipyard_flags = self.shipyard_actor_container.update(board, government_flags=self.government_flags)\n        # self.government_flags = self.government.update(board,\n        #                                                ship_flags=self.ship_flags,\n        #                                                shipyard_flags=self.shipyard_flags)\n\n        return board.current_player.next_actions\n')
    __stickytape_write_module('actors/ship_actor_container.py', 'from actors.actor_container import ActorContainer\nfrom actors.ship_actor import ShipActor\n\n\nclass ShipActorContainer(ActorContainer):\n    def create_actor(self, entity):\n        return ShipActor(entity)\n\n    def get_entity_list(self):\n        return self.board.current_player.ships\n\n    def update(self, board, government_flags):\n        return super().update(board, government_flags)\n')
    __stickytape_write_module('actors/actor_container.py', 'from utils.entity_utils import get_entity_by_id\n\n\nclass ActorContainer():\n    def __init__(self):\n        self.actors = []\n        self.board = None\n\n    def get_entity_list(self):\n        raise NotImplementedError\n\n    def create_actor(self, entity):\n        raise NotImplementedError\n\n    def update_actors(self):\n        entity_list = self.get_entity_list()\n\n        last_turn_ids = set(actor.id for actor in self.actors)\n        current_turn_ids = set(entity.id for entity in entity_list)\n\n        removed_ids = last_turn_ids - current_turn_ids\n        remained_ids = current_turn_ids.intersection(last_turn_ids)\n        added_ids = current_turn_ids - last_turn_ids\n\n        self.actors = [actor for actor in self.actors if actor.id not in removed_ids]  # Remove removed entities\n\n        # Update remained entities\n        for entity_id in remained_ids:\n            actor = get_entity_by_id(self.actors, entity_id)\n            entity = get_entity_by_id(entity_list, entity_id)\n            actor.entity = entity\n\n        # Add added entities\n        for entity_id in added_ids:\n            entity = get_entity_by_id(entity_list, entity_id)\n            self.actors.append(self.create_actor(entity))\n\n    def update(self, board, government_flags):\n        self.board = board\n        self.update_actors()\n\n        flags = []\n\n        for actor in self.actors:\n            actor.choose_action(board)\n            flags += actor.flags\n\n        return flags\n')
    __stickytape_write_module('utils/entity_utils.py', 'def get_entity_by_id(entity_list, entity_id):\n    return next(entity for entity in entity_list if entity.id == entity_id)\n')
    __stickytape_write_module('actors/ship_actor.py', 'import random\nfrom enum import Enum, auto\nfrom random import choice\n\nfrom kaggle_environments.envs.halite.helpers import ShipAction\n\nfrom actors.actor import Actor\nfrom utils.board_utils import cell_within_manhattan_distance, CellList, best_cell_heuristic, manhattan_distance\nfrom utils.movement_utils import keep_distance_move, radial_move\n\n\nclass ShipActor(Actor):\n    class FOVTypes(Enum):\n        FLEE_FOV = auto()\n        KEEP_DISTANCE_FOV = auto()\n        SHIPYARD_FOV = auto()\n        HALITE_COLLECTION_FOV = auto()\n\n        @staticmethod\n        def get_default():\n            return {\n                ShipActor.FOVTypes.FLEE_FOV: 2,\n                ShipActor.FOVTypes.KEEP_DISTANCE_FOV: 2,\n                ShipActor.FOVTypes.SHIPYARD_FOV: 12,\n                ShipActor.FOVTypes.HALITE_COLLECTION_FOV: 5\n            }\n\n    # TODO: change epsilon to sensible value\n    def __init__(self, entity, epsilon=0.1, fovs=None):\n        """\n        :param entity: the entity this actor represents\n        :param epsilon: the probability for performing a random action\n        :param fovs:\n        """\n        super().__init__(entity)\n        if fovs is None:\n            fovs = ShipActor.FOVTypes.get_default()\n        self.epsilon = epsilon\n        self.fovs = fovs\n\n    def normal_mode(self, board):\n        # TODO: remove magic number (replace with parameter) and magic string (replace with enum)\n        if self.entity.halite >= 700:\n            self.mode = \'DEPOSIT\'\n\n        if random.random() < self.epsilon:\n            return choice(\n                [ShipAction.NORTH, ShipAction.EAST, ShipAction.SOUTH, ShipAction.WEST, None]\n            )\n\n        all_entities = CellList(board.cells.values()).entity_list\n\n        fovs_cells = {\n            fov_type: CellList(cell_within_manhattan_distance(board,\n                                                              self.entity.cell,\n                                                              fov_size,\n                                                              board.configuration))\n            for fov_type, fov_size in self.fovs.items()\n        }\n\n        if fovs_cells[ShipActor.FOVTypes.SHIPYARD_FOV] \\\n                .entity_list \\\n                .amount(friendly_only=True, entity_types=[\'shipyard\']) < 1:\n            # Convert to shipyard\n            return ShipAction.CONVERT\n        elif fovs_cells[ShipActor.FOVTypes.KEEP_DISTANCE_FOV] \\\n                .entity_list \\\n                .amount(friendly_only=True, entity_types=[\'ship\'], excluded_ids=[self.entity.id]) > 0 \\\n                or fovs_cells[ShipActor.FOVTypes.FLEE_FOV] \\\n                .entity_list \\\n                .amount(enemy_only=True, entity_types=[\'ship\']) > 0:\n            # Keep distance from friendly\n            return keep_distance_move(self.entity.position,\n                                      all_entities.filter(entity_types=[\'ship\'],\n                                                          excluded_ids=[self.entity.id]).positions,\n                                      board.configuration)\n        else:\n            # Use heuristic to go to best cell to mine halite\n            best_cell = best_cell_heuristic(self.entity.position,\n                                            fovs_cells[ShipActor.FOVTypes.HALITE_COLLECTION_FOV],\n                                            board.configuration)\n            return radial_move(self.entity.position, best_cell.position, board.configuration)\n\n    def deposit(self, board):\n        # TODO: don\'t use normal mode like this\n        if self.entity.halite == 0:\n            self.mode = \'NORMAL\'\n            return self.normal_mode(board)\n        all_entities = CellList(board.cells.values()).entity_list\n        friendly_shipyards = all_entities.filter(friendly_only=True, entity_types=[\'shipyard\'])\n        if len(friendly_shipyards) < 1:\n            return ShipAction.CONVERT\n        nearest_shipyard = min(friendly_shipyards, key=lambda s: manhattan_distance(self.entity.position,\n                                                                                    s.position,\n                                                                                    board.configuration))\n        return radial_move(self.entity.position, nearest_shipyard.position, board.configuration)\n\n    def define_modes(self):\n        modes = {\n            \'NORMAL\': self.normal_mode,\n            \'DEPOSIT\': self.deposit,\n        }\n\n        default_mode = \'NORMAL\'\n\n        return modes, default_mode\n')
    __stickytape_write_module('actors/actor.py', 'class Actor:\n    def __init__(self, entity):\n        """\n        :param entity: the entity this actor represents\n        """\n        self._entity = entity\n        self._modes, self.default_mode = self.define_modes()\n        self._mode = self.default_mode\n        self.flags = []\n\n    @property\n    def id(self):\n        return self.entity.id\n\n    @property\n    def entity(self):\n        return self._entity\n\n    @entity.setter\n    def entity(self, entity):\n        self._entity = entity\n\n    @property\n    def mode(self):\n        return self._mode\n\n    @mode.setter\n    def mode(self, mode):\n        self._mode = mode\n\n    def raise_flag(self, flag):\n        self.flags.append(flag)\n\n    def define_modes(self):\n        raise NotImplementedError\n\n    def choose_action(self, board):\n        self.entity.next_action = self._modes[self.mode](board)\n')
    __stickytape_write_module('utils/board_utils.py', 'import numpy as np\nfrom kaggle_environments.envs.halite.helpers import ShipAction, Point, Ship, Shipyard\n\n# TODO: make this less ugly\nSHIP_MOVEMENT_ACTIONS = list(ShipAction)[:4]\nENTITY_NAME_TO_TYPE = {\n    \'ship\': Ship,\n    \'shipyard\': Shipyard\n}\nENTITY_TYPE_TO_NAME = {v: k for k, v in ENTITY_NAME_TO_TYPE.items()}\n\n\ndef get_xy_distances(point1, point2, config):\n    """\n    Get minimal distances in each axis\n    :param point1:\n    :param point2:\n    :param config:\n    :return: tuple (distance_x, distance_y)\n    """\n    max_x = max(point1.x, point2.x)\n    min_x = min(point1.x, point2.x)\n    distance_x = min(max_x - min_x, min_x - max_x + config.size)\n\n    max_y = max(point1.y, point2.y)\n    min_y = min(point1.y, point2.y)\n    distance_y = min(max_y - min_y, min_y - max_y + config.size)\n\n    return distance_x, distance_y\n\n\ndef manhattan_distance(point1, point2, config):\n    """\n    :param point1:\n    :param point2:\n    :param config: the board size\n    :return: manhattan distance between two points\n    """\n    return sum(get_xy_distances(point1, point2, config))\n\n\ndef euclidean_distance(point1, point2, config):\n    """\n    :param point1:\n    :param point2:\n    :param config: the board size\n    :return: euclidean distance between two points\n    """\n    return np.linalg.norm(get_xy_distances(point1, point2, config))\n\n\ndef infinity_distance(point1, point2, config):\n    """\n    :param point1:\n    :param point2:\n    :param config: the board size\n    :return: infinity distance between two points\n    """\n    return max(get_xy_distances(point1, point2, config))\n\n\ndef cells_within_distance(board, cell, distance, distance_fn, config):\n    my_position = cell.position\n    fov_xs = np.arange(0, config.size)\n    fov_ys = np.arange(0, config.size)\n    fov_points = [Point(x, y) for x in fov_xs for y in fov_ys if\n                  distance_fn(Point(x, y), my_position, config) <= distance]\n    return [board.cells[point] for point in fov_points]\n\n\ndef cell_within_euclidean_distance(board, cell, distance, config):\n    """\n    :param board:\n    :param cell:\n    :param distance:\n    :param config: the board size\n    :return: all cells with (euclidean distance) <= distance from given cell\n    """\n    return cells_within_distance(board, cell, distance, euclidean_distance, config)\n\n\ndef cell_within_infinity_distance(board, cell, distance, config):\n    """\n    :param board:\n    :param cell:\n    :param distance:\n    :param config: the board size\n    :return: all cells with (infinity distance) <= fov from given cell\n    """\n    return cells_within_distance(board, cell, distance, infinity_distance, config)\n\n\ndef cell_within_manhattan_distance(board, cell, distance, config):\n    """\n    :param board:\n    :param cell:\n    :param distance:\n    :param config: the board size\n    :return: all cells with (manhattan distance) <= fov from given cell\n    """\n    return cells_within_distance(board, cell, distance, manhattan_distance, config)\n\n\nclass CellList(list):\n    def __init__(self, cells):\n        super().__init__(cells)\n\n    @property\n    def entity_list(self):\n        return EntityList(\n            filter(lambda x: x is not None, [cell.ship for cell in self] + [cell.shipyard for cell in self])\n        )\n\n\nclass EntityList(list):\n    def __init__(self, entities):\n        super().__init__(entities)\n\n    def nearest_entity_to(self, point, config, distance_fn=manhattan_distance):\n        return min(self, key=lambda entity: distance_fn(entity.position, point, config))\n\n    @property\n    def positions(self):\n        return [e.position for e in self]\n\n    def filter(self, players=None, entity_types=(\'ship\', \'shipyard\'), friendly_only=False, enemy_only=False,\n               excluded_ids=()):\n        def predicate(e):\n            return (players is None or e.player in players) and \\\n                   (ENTITY_TYPE_TO_NAME[type(e)] in entity_types) and \\\n                   (not friendly_only or e.player.is_current_player) and \\\n                   (not enemy_only or not e.player.is_current_player) and \\\n                   (e.id not in excluded_ids)\n\n        return EntityList(list(filter(lambda e: predicate(e), self)))\n\n    def amount(self, **kwargs):\n        return len(self.filter(**kwargs))\n\n\ndef get_neighbors(point, config):\n    return [(movement, (point + movement.to_point()) % config.size) for movement in SHIP_MOVEMENT_ACTIONS]\n\n\ndef future_halite_in_cell(cell, steps, config):\n    return min(cell.halite * (1 + config.regen_rate) ** steps, config.max_cell_halite)\n\n\ndef cell_reward(current_position, cell, config):\n    distance_to_cell = manhattan_distance(current_position, cell.position, config)\n    cell_halite = future_halite_in_cell(cell, distance_to_cell, config)\n\n    collected_turns = 1\n    collected_halite = config.collect_rate * cell_halite\n    max_reward = collected_halite / (distance_to_cell + collected_turns)\n    remaining_cell_halite = cell_halite - collected_halite\n\n    min_cell_halite = 30\n    # TODO: verify no bugs\n    while remaining_cell_halite > min_cell_halite:\n        collected_turns += 1\n        collected_halite += config.collect_rate * remaining_cell_halite\n        max_reward = max(max_reward, collected_halite / (distance_to_cell + collected_turns))\n        remaining_cell_halite = cell_halite - collected_halite\n    return max_reward\n\n\ndef best_cell_heuristic(current_position, cells, config):\n    """\n    Use heuristic to find the best cell to go to from the given list of cells\n    :param current_position:\n    :param cells: list of cells to check\n    :param config: the env configuration\n    :return: return best point by heuristic\n    """\n    return max(cells, key=lambda cell: cell_reward(current_position, cell, config))\n')
    __stickytape_write_module('utils/movement_utils.py', 'import numpy as np\nfrom kaggle_environments.envs.halite.helpers import ShipAction\n\nfrom utils.board_utils import euclidean_distance, get_neighbors, manhattan_distance, SHIP_MOVEMENT_ACTIONS\n\n\n# TODO: move by distance_fn\n\ndef radial_move(current_point, destination_position, config):\n    """\n    Get the ShipAction movement that gets you closest to the destination (in euclidean distance)\n    :param current_point:\n    :param destination_position:\n    :param board_size:\n    :return: ShipAction\n    """\n\n    if current_point == destination_position:\n        return None\n\n    neighbors = get_neighbors(current_point, config)\n    return min([(movement, manhattan_distance(neighbor, destination_position, config))\n                for movement, neighbor in neighbors], key=lambda x: x[1])[0]\n\n\ndef keep_distance_move(current_point, entities_positions, config):\n    """\n    Get the ShipAction movement that gets you farthest from all given entities (in euclidean distance)\n    :param current_point:\n    :param entities_positions:\n    :param board_size:\n    :return:\n    """\n\n    neighbors = get_neighbors(current_point, config)\n\n    distances = [config.size ** 2] * 4\n\n    for entity_position in entities_positions:\n        distances = [min(distances[i], euclidean_distance(neighbors[i][1], entity_position, config)) for i in\n                     range(len(SHIP_MOVEMENT_ACTIONS))]\n\n    index = distances.index(max(distances))\n    return SHIP_MOVEMENT_ACTIONS[index]\n')
    __stickytape_write_module('actors/shipyard_actor_container.py', 'from actors.actor_container import ActorContainer\nfrom actors.shipyard_actor import ShipyardActor\n\n\nclass ShipyardActorContainer(ActorContainer):\n    def create_actor(self, entity):\n        return ShipyardActor(entity)\n\n    def get_entity_list(self):\n        return self.board.current_player.shipyards\n\n    def update(self, board, government_flags):\n        return super().update(board, government_flags)\n')
    __stickytape_write_module('actors/shipyard_actor.py', "from kaggle_environments.envs.halite.helpers import ShipyardAction\n\nfrom actors.actor import Actor\nfrom government.flags import Flag, NotEnoughHaliteFlag\n\n\nclass ShipyardActor(Actor):\n    def normal_mode(self, board):\n        missing_halite = board.configuration.spawn_cost - board.current_player.halite\n        if missing_halite > 0:\n            self.raise_flag(NotEnoughHaliteFlag(missing_halite))\n            return None\n        return ShipyardAction.SPAWN\n\n    def define_modes(self):\n        modes = {\n            'NORMAL': self.normal_mode,\n        }\n\n        default_mode = 'NORMAL'\n\n        return modes, default_mode\n")
    __stickytape_write_module('government/flags.py', 'class Flag:\n    def __init__(self):\n        pass\n\n\nclass NotEnoughHaliteFlag(Flag):\n    def __init__(self, missing_halite):\n        super().__init__()\n        self.missing_halite = missing_halite\n')
    __stickytape_write_module('agents/base_agent.py', 'class BaseAgent():\n    def __init__(self):\n        pass\n\n    def get_actions(self, board):\n        raise NotImplementedError\n')
    __stickytape_write_module('government/government.py', 'class Government:\n    def __int__(self):\n        pass\n\n    def update(self, board, ship_flags, shipyard_flags):\n        pass\n')
    from kaggle_environments.envs.halite.helpers import Board
    
    from agents.distributed_agent import DistributedAgent
    
    agent = None
    
    
    def run_step(observation, config):
        # print('hello')
    
        global agent
    
        if agent is None:
            agent = DistributedAgent()
    
        board = Board(observation, config)
    
        return agent.get_actions(board)
    